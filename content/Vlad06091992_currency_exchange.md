# Код-ревью проекта Currency Exchange API
- [GitHub](https://github.com/Vlad06091992/java_roadmap_currency)

## Соблюдение разделения на слои

### Controller (Servlets)
- **Плюсы**: Каждый сервлет отвечает за один ресурс, использует services для бизнес-логики.
- **Минусы**: Нет DI, services создаются в конструкторах. Парсинг параметров в Utils, что нарушает SRP.

### Service слой
- **Плюсы**: Services содержат бизнес-логику, валидацию, маппинг в JSON.
- **Минусы**: Возвращают JSON строки вместо объектов, что смешивает слои. Нет DTO для разделения.

### Repository (DAO слой)
- **Плюсы**: Реализуют generic DAO, поддерживают CRUD.
- **Минусы**: DatabaseAdapter — самописный ORM с reflection и аннотациями, слишком сложный. Нет try-with-resources, утечки ресурсов.

### Domain слой (Entities)
- **Плюсы**: Entities с геттерами/сеттерами, аннотациями для запросов.
- **Минусы**: Аннотации переусложняют, лучше простой POJO. Exchange наследуется от ExchangeRate странно.

## Соблюдение Java Naming Conventions

- **Плюсы**: Классы PascalCase, методы camelCase, переменные camelCase.
- **Минусы**: Не все пакеты lowercase. "Utilites" опечатка — "Utilities". Константы не uppercase.

## Качество реализации REST

- **Эндпоинты и методы**:
    - GET /currencies — список валют (200)
    - POST /currencies — создание валюты (201)
    - GET /currency/{code} — валюта по коду (200)
    - GET /exchangeRates — список курсов (200)
    - POST /exchangeRates — создание курса (201)
    - GET /exchangeRate/{base}{target} — курс по паре (200)
    - PATCH /exchangeRate/{base}{target} — обновление курса (200)
    - GET /exchange?from=...&to=...&amount=... — конверсия (200)
- **Коды ответов**: Правильно 200, 201, 400, 404, 409, 500.
- **Формат**: JSON, параметры query/form.

## Обработка ошибок и валидация

- **Обработка ошибок**: Кастомные исключения, маппинг в http кодов в servlets.
- **Валидация**: В services проверка полей, rate > 0, amount > 0.
- **Минусы**: Валидация разбросана

## Общая структура проекта и код-стайл

- **Структура**: Maven, слои в пакетах, resources для конфига.
- **Код-стайл**: Консистентный, но много TODO и e.printStackTrace().
- **Минусы**: Переусложнение с аннотациями и reflection.

## Настройка подключений к БД

- **Плюсы**: Использует .env для секретов, HikariCP неявно.
- **Минусы**: DatabaseAdapter создает connection без пула, DriverManager.getConnection каждый раз — неэффективно. application.yml не используется.

## Минусы ключевых классов и упрощенные варианты

### Currency
- Минус 1: Аннотации для запросов переусложняют.
- Минус 2: Нет валидации в entity.
- Упрощение: Убрать аннотации, сделать record или классический класс Currency(String code, String name, String sign, int id).

### ExchangeRate
- Минус 1: Сложный конструктор с массивами.
- Минус 2: FindByIdQuery сломан.
- Упрощение: Простой класс с полями, без аннотаций.

### DatabaseAdapter
- Минус 1: Reflection для создания entities — слишком сложно.
- Минус 2: Нет try-with-resources.
- Упрощение: Использовать JDBC с RowMapper.

### ExchangeRatesDAO
- Минус 1: findByCodes делает 3 запроса.
- Минус 2: update использует raw query.
- Упрощение: Один JOIN запрос для findByCodes.

### CurrencyService
- Минус 1: Возвращает JSON строки.
- Минус 2: Валидация в цикле.
- Упрощение: Возвращать Currency, маппинг в JSON в controller.

### ExchangeService
- Минус 1: Сложная логика конверсии в одном методе.
- Минус 2: Дублирование кода для reversed rate.
- Упрощение: Вынести логику в отдельные методы.

### CurrenciesServlet
- Минус 1: Логика обработки исключений повторяется.
- Упрощение: Общий базовый servlet для обработки ошибок.

### Utils
- Минус 1: parseQueryParams ломает если queryString null.
- Минус 2: Дублирует логику парсинга.
- Упрощение: Использовать библиотеку вроде Apache Commons.

## Заключение по архитектуре

### Что хорошо
- Разделение слоев соблюдается.
- REST API работает корректно.
- Использование исключений для ошибок.

### Что нужно улучшить в первую очередь
1. **Упростить DAO**: Убрать аннотации и рефлексию, использовать простой JDBC.
2. **Добавить DI**: Можно как отдельный класс, который создаст нужные экземпляры, а можно как самописный DI-контейнер.
3. **Валидация**: Валидацию можно сделать централизованной.
4. **Обработка ошибок**: Лучше делать глобальный фильтр вместо повторения в servlets.
5. **БД**: Настроить connection pool.

Самописный ORM - изобретения велосипеда. Нужно упрощать код, а не усложнять его. Моя рекомендация - научиться писать простой код, чтобы понимать основы архитектуры и соблюдать код-стайл. Простой код - просто читать, в отличие от сложного кода. В реальных проектах ценят простоту.
